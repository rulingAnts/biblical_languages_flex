<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex,nofollow" />
  <title>FLEx Interlinear (Web)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;max-width:900px;margin:0 auto;padding:20px;background:#f7f7f7}
    h1{color:#0b5ed7}
    .card{background:#fff;border:1px solid #e4e4e4;border-radius:8px;padding:16px;margin:16px 0;box-shadow:0 1px 3px rgba(0,0,0,.06)}
    label{display:block;margin:.25rem 0 .25rem;color:#333}
    input[type="text"],select{width:100%;max-width:420px;padding:8px;border:1px solid #ccc;border-radius:4px}
    button{background:#198754;color:#fff;border:0;border-radius:4px;padding:8px 14px;cursor:pointer}
    button.secondary{background:#6c757d}
    #preview{font-family:monospace;white-space:pre-wrap;border:1px solid #0b5ed7;background:#eef6ff;border-radius:6px;padding:10px}
    .muted{color:#666;font-size:.9em}
    .row{display:flex;gap:10px;align-items:center}
    a { color:#0b5ed7; }
  </style>
</head>
<body>
  <h1>ðŸ“– FLEx Interlinear (Web-only)</h1>
  <div class="card">
    <p>This web app allows you to generate an interlinearized flextext file that you can import into FieldWorks Language Explorer project (see template below) as an interlinear text. It doesn't link to lexical items, but it does include word glosses, and is immediately useable in text charting (and maybe tagging) view.</p>
    <p class="muted">
      This is a browser-only version. All data loads from this folder (GitHub Pages). No server is required.
    </p>
    <div id="protocol-warning" class="muted" style="display:none;color:#dc3545;margin-bottom:8px;">
      Tip: Open this page via http(s) (e.g., using the local test server) so JSON can load. File URLs often block fetch.
    </div>
    <label for="book">Book</label>
    <select id="book" style="max-width:420px;margin-bottom:8px;"></select>
    <div class="row">
  <label for="ref">Reference (within selected book; supports: 28, 27-28, 28:19, 28:19-20, 28-19-20, 28:19-29:3)</label>
    </div>
    <input id="ref" type="text" value="1:1-1:3" />

    <div style="margin-top:10px;">
      <button id="load">Load</button>
      <button id="download" class="secondary" disabled>Generate .flextext</button>
    </div>

    <p class="muted" style="margin-top:6px;">
      Tip: for easiest import into FieldWorks, use the FLEx template project in the Downloads section below
      (<a href="assets/NT%20Greek%20blank%20project.fwbackup" download>download template</a>).
    </p>

    <div id="status" class="muted" style="margin-top:10px;"></div>

    <div id="preview" style="margin-top:10px;">Awaiting dataâ€¦</div>
  </div>

  <div class="card">
    <h3>Downloads</h3>
    <ul>
      <li><a id="flex-template-link" href="assets/NT%20Greek%20blank%20project.fwbackup" download>FLEx template project (.fwbackup)</a></li>
      <li><a href="assets/strongs_greek.json" download>Strongâ€™s Glosses (TBESG) JSON</a></li>
      <li><a href="sword_repo/" target="_blank" rel="noopener">SWORD modules packaged with this app</a> (for transparency; not used directly in-browser)</li>
    </ul>
    <p class="muted">
      Tip: You can import the generated .flextext into the FLEx template project above for best results.
    </p>
  </div>

  <div class="card">
    <h3>Attributions and License</h3>
    <ul>
      <li>Greek text and morphology: MorphGNT lemmatization and parsing by James Tauber (CC BY-SA). Base text: SBLGNT Â© 2010 Logos Bible Software and the Society of Biblical Literature.</li>
      <li>Strongâ€™s glosses: TBESG â€“ Tyndale Brief lexicon of Extended Strongâ€™s for Greek, from www.STEPBible.org by Tyndale House Cambridge and others (CC BY 4.0).</li>
  <li>Translation: Lexham English Bible (LEB). Scripture quotations are from the LEB. Â© Logos Bible Software. Used under the LEB license: http://www.lexhamenglishbible.com/license/</li>
    </ul>
  </div>

  <script>
  // Data layout: docs/assets/data/<Book>.json with mapping of "C:V" => { words:[{g, S, l, gls}], translation: string }
  // We load exactly one book at a time via the dropdown; references are chapter:verse or chapter:verse-chapter:verse within that book.
  const statusEl = document.getElementById('status');
  const previewEl = document.getElementById('preview');
  const refInput = document.getElementById('ref');
  const bookSelect = document.getElementById('book');
  const downloadBtn = document.getElementById('download');

  const BOOKS = [
    'Matthew','Mark','Luke','John','Acts','Romans','1Corinthians','2Corinthians','Galatians','Ephesians','Philippians','Colossians','1Thessalonians','2Thessalonians','1Timothy','2Timothy','Titus','Philemon','Hebrews','James','1Peter','2Peter','1John','2John','3John','Jude','Revelation'
  ];

  const cache = {}; // book -> json data
  let currentBook = null;
  let currentPassage = null;
  let currentVerses = null;

  document.getElementById('load').addEventListener('click', async () => {
    status('Loadingâ€¦');
    try {
      const passage = parseRange(refInput.value.trim());
      await ensureBookLoaded(currentBook);
      const verses = sliceVerses(cache[currentBook], { book: currentBook, ...passage });
      currentPassage = { book: currentBook, ...passage };
      currentVerses = verses;
      renderPreview(currentPassage, verses);
      downloadBtn.disabled = false;
      status('Loaded.');
    } catch (e) {
      status('Error: ' + e.message, true);
      previewEl.textContent = 'â€”';
      downloadBtn.disabled = true;
    }
  });

  document.getElementById('download').addEventListener('click', async () => {
    try {
      if (!currentVerses || !currentPassage) {
        // Fallback: attempt to load
        const passage = parseRange(refInput.value.trim());
        await ensureBookLoaded(currentBook);
        currentPassage = { book: currentBook, ...passage };
        currentVerses = sliceVerses(cache[currentBook], currentPassage);
      }
      const xml = buildFlexText(currentPassage, currentVerses);
      const blob = new Blob([xml], { type: 'application/xml' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = buildFilename(currentPassage);
      a.click();
      URL.revokeObjectURL(a.href);
    } catch (e) {
      status('Error: ' + e.message, true);
    }
  });

  function status(msg, isError=false){
    statusEl.textContent = msg;
    statusEl.style.color = isError ? '#dc3545' : '#333';
  }

  function parseRange(ref){
    const s = (ref || '').trim();
    // 1) Cross-chapter verse range: C:V - C:V  e.g., 28:19-29:3
    let m = s.match(/^(\d+):(\d+)\s*-\s*(\d+):(\d+)$/);
    if (m) {
      const start = { c: parseInt(m[1],10), v: parseInt(m[2],10) };
      const end = { c: parseInt(m[3],10), v: parseInt(m[4],10) };
      if(end.c < start.c || (end.c===start.c && end.v < start.v)) throw new Error('End precedes start.');
      return { start, end };
    }
    // 1b) Same-chapter verse range shorthand: C:V - V  e.g., 28:19-20
    m = s.match(/^(\d+):(\d+)\s*-\s*(\d+)$/);
    if (m) {
      const c = parseInt(m[1],10);
      const sv = parseInt(m[2],10);
      const ev = parseInt(m[3],10);
      if (ev < sv) throw new Error('End precedes start.');
      return { start: { c, v: sv }, end: { c, v: ev } };
    }
    // 2) Chapter - startVerse - endVerse: e.g., 28-19-20
    m = s.match(/^(\d+)\s*-\s*(\d+)\s*-\s*(\d+)$/);
    if (m) {
      const c = parseInt(m[1],10);
      const sv = parseInt(m[2],10);
      const ev = parseInt(m[3],10);
      if (ev < sv) throw new Error('End precedes start.');
      return { start: { c, v: sv }, end: { c, v: ev } };
    }
    // 3) Single verse C:V
    m = s.match(/^(\d+):(\d+)$/);
    if (m) {
      const c = parseInt(m[1],10), v = parseInt(m[2],10);
      return { start: { c, v }, end: { c, v } };
    }
    // 4) Chapter range C-C
    m = s.match(/^(\d+)\s*-\s*(\d+)$/);
    if (m) {
      const sc = parseInt(m[1],10), ec = parseInt(m[2],10);
      if (ec < sc) throw new Error('End precedes start.');
      return { start: { c: sc, v: 1 }, end: { c: ec, v: 999 } };
    }
    // 5) Single chapter C
    m = s.match(/^(\d+)$/);
    if (m) {
      const c = parseInt(m[1],10);
      return { start: { c, v: 1 }, end: { c, v: 999 } };
    }
    throw new Error('Invalid reference. Try: 28, 27-28, 28:19, 28-19-20, or 28:19-29:3');
  }

  async function ensureBookLoaded(book){
    if (!book) throw new Error('No book selected.');
    if (cache[book]) return;
    const path = `assets/data/${encodeURIComponent(book)}.json`;
    let res;
    try {
      res = await fetch(path, { cache: 'no-store' });
    } catch (e) {
      throw new Error(`Failed to fetch ${path}. Are you serving over http(s)?`);
    }
    if(!res.ok) throw new Error(`Book JSON not found for ${book} (${res.status})`);
    const contentType = (res.headers.get('content-type') || '').toLowerCase();
    const text = await res.text();
    try {
      if (!contentType.includes('application/json') && text.trim().startsWith('<')) {
        throw new Error(`Expected JSON but received HTML. URL: ${path}`);
      }
      cache[book] = JSON.parse(text);
    } catch (e) {
      console.error('Failed to parse JSON for', path, 'Content-Type:', contentType, 'First 120 chars:', text.slice(0,120));
      throw new Error(`Failed to parse JSON for ${book}. Check if the file exists at ${path}.`);
    }
  }

  function sliceVerses(bookData, passage){
    const verses = [];
    for(let c = passage.start.c; c <= passage.end.c; c++){
      const vStart = (c === passage.start.c) ? passage.start.v : 1;
      const vEnd = (c === passage.end.c) ? passage.end.v : 999;
      for(let v=vStart; v<=vEnd; v++){
        const key = `${c}:${v}`;
        const verse = bookData[key];
        if(verse) verses.push({ ref: `${passage.book} ${key}`, ...verse, c, v });
      }
    }
    if(!verses.length) throw new Error('No verses found for that range.');
    return verses;
  }

  function renderPreview(passage, verses){
    let out = `Reference: ${passage.book} ${passage.start.c}:${passage.start.v}`;
    if(passage.end.c !== passage.start.c || passage.end.v !== passage.start.v){
      out += `-${passage.end.c}:${passage.end.v}`;
    }
    out += `\nVerses Loaded: ${verses.length}\n\n`;
    verses.slice(0,3).forEach(v => {
      out += `${v.ref}\n`;
      (v.words||[]).slice(0,5).forEach(w => {
        out += `  ${w.g} (${w.S||''}) - ${w.gls||''}\n`;
      });
    });
    previewEl.textContent = out;
  }

  function buildFilename(passage){
    const startPart = `${passage.start.c}_${passage.start.v}`;
    const endPart = (passage.end.c === passage.start.c && passage.end.v === passage.start.v)
      ? ''
      : `-${passage.end.c}_${passage.end.v}`;
    return `${passage.book}_${startPart}${endPart}.flextext`;
  }

  function esc(s){
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  }

  function buildFlexText(passage, verses){
    // Build a FLEx-compliant FlexText document with:
    // - single <interlinear-text guid="..."> container
    // - <item type="title"> and <item type="title-abbreviation">
    // - wrappers: <paragraphs>/<phrases>/<words>
    // - GUIDs for interlinear-text, phrase, and word

    // Helpers
    const bookAbbr = (function(){
      const M = {
        Matthew: 'Mt', Mark: 'Mk', Luke: 'Lk', John: 'Jn', Acts: 'Ac', Romans: 'Ro',
        '1Corinthians': '1Co', '2Corinthians': '2Co', Galatians: 'Ga', Ephesians: 'Eph',
        Philippians: 'Php', Colossians: 'Col', '1Thessalonians': '1Th', '2Thessalonians': '2Th',
        '1Timothy': '1Ti', '2Timothy': '2Ti', Titus: 'Tit', Philemon: 'Phm', Hebrews: 'Heb',
        James: 'Jas', '1Peter': '1Pe', '2Peter': '2Pe', '1John': '1Jn', '2John': '2Jn', '3John': '3Jn',
        Jude: 'Jud', Revelation: 'Rev'
      };
      return M[passage.book] || passage.book.slice(0,3);
    })();

    const title = `${passage.book} ${passage.start.c}:${passage.start.v}` +
      ((passage.end.c !== passage.start.c || passage.end.v !== passage.start.v) ? `-${passage.end.c}:${passage.end.v}` : '');
    const titleAbbr = (function(){
      const startPart = `${bookAbbr}${passage.start.c}_${passage.start.v}`;
      const endPart = (passage.end.c === passage.start.c && passage.end.v === passage.start.v)
        ? ''
        : `-${(passage.end.c === passage.start.c) ? passage.end.v : `${passage.end.c}_${passage.end.v}`}`;
      return `${startPart}${endPart}`;
    })();

    function uuidv4(){
      if (window.crypto && crypto.getRandomValues) {
        const buf = new Uint8Array(16);
        crypto.getRandomValues(buf);
        // RFC4122 v4
        buf[6] = (buf[6] & 0x0f) | 0x40;
        buf[8] = (buf[8] & 0x3f) | 0x80;
        const bth = Array.from(buf, b => b.toString(16).padStart(2,'0'));
        return `${bth[0]}${bth[1]}${bth[2]}${bth[3]}-${bth[4]}${bth[5]}-${bth[6]}${bth[7]}-${bth[8]}${bth[9]}-${bth[10]}${bth[11]}${bth[12]}${bth[13]}${bth[14]}${bth[15]}`;
      }
      // Fallback
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = Math.random()*16|0, v = c=='x'?r:(r&0x3|0x8);
        return v.toString(16);
      });
    }

    let xml = '';
    xml += "<?xml version='1.0' encoding='utf-8'?>\n";
    xml += '<document version="2">\n';
    const docGuid = uuidv4(); // not used as attribute on document, but keep if needed later
    const ilGuid = uuidv4();
    xml += `<interlinear-text guid="${ilGuid}">\n`;
    xml += `  <item type="title" lang="en">${esc(title)}</item>\n`;
    xml += `  <item type="title-abbreviation" lang="en">${esc(titleAbbr)}</item>\n`;
    xml += '  <paragraphs>\n';
    xml += '    <paragraph>\n';
    xml += '      <phrases>\n';

    let seg = 1; // segment numbers start at 1 and increment per phrase
    verses.forEach(v => {
      const greekText = (v.words||[]).map(w => w.g).join(' ');
      const phraseGls = v.translation || '';
      const phraseGuid = uuidv4();
      xml += `        <phrase guid="${phraseGuid}">\n`;
      // Correct order: txt, segnum, words, gls
      xml += '          <item type="txt" lang="grc">' + esc(greekText) + '</item>\n';
      xml += '          <item type="segnum" lang="en">' + esc(seg) + '</item>\n';
      xml += '          <words>\n';
      (v.words||[]).forEach(w => {
        const wordGuid = uuidv4();
        xml += `            <word guid="${wordGuid}">\n`;
        xml += '              <item type="txt" lang="grc">' + esc(w.g) + '</item>\n';
        if(w.gls) xml += '              <item type="gls" lang="en">' + esc(w.gls) + '</item>\n';
        xml += '            </word>\n';
      });
      xml += '          </words>\n';
      xml += '          <item type="gls" lang="en">' + esc(phraseGls) + '</item>\n';
      xml += '        </phrase>\n';
      seg += 1;
    });

    xml += '      </phrases>\n';
    xml += '    </paragraph>\n';
    xml += '  </paragraphs>\n';
    xml += '</interlinear-text>\n';
    xml += '</document>\n';
    return xml;
  }

  // --- Initialization ---
  (function init(){
    if (location.protocol !== 'http:' && location.protocol !== 'https:') {
      document.getElementById('protocol-warning').style.display = 'block';
    }
    // Populate books
    BOOKS.forEach(b => {
      const opt = document.createElement('option');
      opt.value = b; opt.textContent = b;
      bookSelect.appendChild(opt);
    });
    // default select John
    currentBook = 'John';
    bookSelect.value = currentBook;
    ensureBookLoaded(currentBook).then(() => {
      status(`Loaded book data: ${currentBook}. Enter a reference like 1:1-1:3 and click Load.`);
    }).catch(e => status('Error: ' + e.message, true));

    bookSelect.addEventListener('change', async () => {
      currentBook = bookSelect.value;
      downloadBtn.disabled = true;
      currentPassage = null;
      currentVerses = null;
      status(`Loading book: ${currentBook}â€¦`);
      try {
        await ensureBookLoaded(currentBook);
        status(`Loaded book data: ${currentBook}.`);
        previewEl.textContent = 'Awaiting dataâ€¦';
      } catch (e) {
        status('Error: ' + e.message, true);
      }
    });
  })();
  </script>
</body>
</html>
